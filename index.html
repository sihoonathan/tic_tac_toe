<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Title</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Grandstander:wght@300;800&display=swap" rel="stylesheet">

  </head>
  <body>
    <div id="overlay"></div>
    <header>
      <p>Tic-Tac-Toe</p>
    </header>
    <section id="choice">
      <button data-type="O">O</button>
      <button data-type="X">X</button>
    </section>
    <section id="resetSec" class="displayNone">
      <button id="reset">Play Again</button>
    </section>
    <section id="mainBoard">
      <div data-row="1" data-col="1"></div>
      <div data-row="1" data-col="2"></div>
      <div data-row="1" data-col="3"></div>
      <div data-row="2" data-col="1"></div>
      <div data-row="2" data-col="2"></div>
      <div data-row="2" data-col="3"></div>
      <div data-row="3" data-col="1"></div>
      <div data-row="3" data-col="2"></div>
      <div data-row="3" data-col="3"></div>
    </section>
    <section id="footer" class="displayNone">
      <p id="message">Hi</p>
    </section>
    <script>
      let player = null;
      let opponent = null;
      let turn = null;
      
      const switchTurn = () => {
          if (turn === player) turn = opponent;
          else turn = player;
      };

      const checkWinner = () => {
          let foundWinner = false;
          let divs = document.querySelectorAll("#mainBoard > div");
          
          //checks for row winning pattern
          for (let row = 1; row <= 3; row++) {
              let possibleWinner = [];
              let winnerDivs = [];
              for (let col = 1; col <= 3; col++) {
                  let matchedDiv;
                  divs.forEach(div => {
                      if (div.dataset.row == row && div.dataset.col == col) {
                          matchedDiv = div;
                      }
                  });
                  possibleWinner.push(matchedDiv.innerText);
                  winnerDivs.push(matchedDiv);
              }
              
              for (let i = 0; i < possibleWinner.length - 1; i++) {
                  // debugger;
                  let curr = possibleWinner[i];
                  let next = possibleWinner[i + 1]
                  
                  if (curr != next || curr == "") {
                      break;
                  }
                  if (i == possibleWinner.length - 2) {
                      foundWinner = true;
                      for (let each of winnerDivs) {
                          each.classList.add('winnerColor');
                      }
                  }
              }
          }
          
          //checks for column winning pattern
          for (let col = 1; col <= 3; col++) {
              let possibleWinner = []
              let winnerDivs = [];
              
              for (let row = 1; row <= 3; row++) {
                  let matchedDiv;
                  divs.forEach(div => {
                      if (div.dataset.row == row && div.dataset.col == col) {
                          matchedDiv = div;
                      }
                  });
                  possibleWinner.push(matchedDiv.innerText);
                  winnerDivs.push(matchedDiv);

              }

              for (let i = 0; i < possibleWinner.length - 1; i++) {
                  // debugger;
                  let curr = possibleWinner[i];
                  let next = possibleWinner[i + 1]

                  if (curr != next || curr == "") {
                      break;
                  }
                  if (i == possibleWinner.length - 2) {
                      foundWinner = true;
                      for (let each of winnerDivs) {
                          each.classList.add('winnerColor');
                      }
                  }
              }
          }

          let start = 1;
          let end = 3;

          //Checks for right diagonal winning pattern
          let possibleWinner = [];
          let winnerDivs = [];

          for (let row = start; row <= end; row++) {
              let col = row;
              let matchedDiv;
              divs.forEach(div => {
                  if (div.dataset.row == row && div.dataset.col == col) {
                      matchedDiv = div;
                  }
              });
              possibleWinner.push(matchedDiv.innerText);
              winnerDivs.push(matchedDiv);

          }
          
          for (let i = 0; i < possibleWinner.length - 1; i++) {
              // debugger;
              let curr = possibleWinner[i];
              let next = possibleWinner[i + 1]

              if (curr != next || curr == "") {
                  break;
              }
              if (i == possibleWinner.length - 2) {
                  foundWinner = true;
                  for (let each of winnerDivs) {
                      each.classList.add('winnerColor');
                  }
              }
          }
          
          //Checks for left diagonal winning pattern
          possibleWinner = [];
          winnerDivs = [];

          for (let row = start; row <= end; row++) {
              let col = 4 - row;
              let matchedDiv;
              divs.forEach(div => {
                  if (div.dataset.row == row && div.dataset.col == col) {
                      matchedDiv = div;
                  }
              });
              possibleWinner.push(matchedDiv.innerText);
              winnerDivs.push(matchedDiv);

          }
          for (let i = 0; i < possibleWinner.length - 1; i++) {
              // debugger;
              let curr = possibleWinner[i];
              let next = possibleWinner[i + 1]

              if (curr != next || curr == "") {
                  break;
              }
              if (i == possibleWinner.length - 2) {
                  foundWinner = true;
                  for (let each of winnerDivs) {
                      each.classList.add('winnerColor');
                  }
              }
          }
          
          //
          
          
          return foundWinner;
      };
      
      const reset = () => {
          document.querySelector('#resetSec').classList.add('displayNone');
          document.querySelector('#footer').classList.add('displayNone');
          document.querySelector('#overlay').classList.remove('overlay');
          gameBoard.splice(0, gameBoard.length);
          // debugger;
          let msg = document.querySelector("#message");
          msg.innerHTML = "";
          let divs = document.querySelectorAll('div');
          divs.forEach(div => {
              div.classList.remove('winnerColor');
          })
          renderBoard();
      };
      
      const gameBoard = (() => {

          const resetBtn = document.querySelector('#reset');
          resetBtn.addEventListener('click', reset);
          resetBtn.addEventListener('click', () => {
              
              resetBtn.classList.add('bigger');
          });
          resetBtn.addEventListener('transitionend', () => {
              resetBtn.classList.remove('bigger');
          });
          const btns = document.querySelectorAll('#choice > button');
         
          btns.forEach(btn => {
              btn.addEventListener('click', () => {
                  btn.classList.add('bigger');
                  
                  if (board.length == 0) {
                      player = Player(btn.dataset.type);
                      opponent = (player.type == 'O' ? Player('X') : Player('O'));
                      turn = player;
                  }
              })
              
              btn.addEventListener('transitionend', () => {
                  // debugger
                  btn.classList.remove('bigger');
              })
          });
          const board = [];

          let boxes = document.querySelectorAll('#mainBoard > div');
          boxes.forEach(box => {
              
              box.addEventListener('mouseover', () => {
                  if (box.innerHTML == "" && !checkWinner()) {
                      box.innerHTML = turn.type;
                      box.classList.add('dim');
                  }
                  
              });
              
              box.addEventListener('mouseout', () => {
                  if (box.classList.contains('dim')) {
                      box.innerHTML = "";
                      box.classList.remove('dim');
                  }
              })
              
              box.addEventListener('click', () => {
                  box.innerHTML = "";
                  box.classList.remove('dim');
                  
                  let row = box.dataset.row;
                  let col = box.dataset.col;
                  
                  outer:
                      for (let i = 0; i < 1; i++) {
                        for (let move of gameBoard) {
                          if (move.row == row && move.col == col) {
                              break outer;
                          }
                        }
                          turn.addMove(row, col);
                          board.push(turn.moves[turn.moves.length-1]);
                          if (!checkWinner()) {
                              renderBoard();
                          }
                          if (checkWinner()) {
                              let msg = document.querySelector("#message");
                              msg.innerHTML = `Winner is '${turn.type}' player`;

                              document.querySelector('#resetSec').classList.remove('displayNone');
                              document.querySelector('#footer').classList.remove('displayNone');
                              document.querySelector('#overlay').classList.add('overlay');
                              break outer;
                          };
                          
                          checkDraw();
                          
                          switchTurn();
                      }
              })
          });
          
          return board;
      })();
      
      const Player = (type) => {
          const moves = [];
          const addMove = (row, col) => {
              moves.push({type, row, col})
          };
          return {type, moves, addMove};
      };
      
      const renderBoard = () => {

          let divs = document.querySelectorAll('#mainBoard > div');
          divs.forEach(div => {
              div.innerHTML = "";
          })
          
          for (let move of gameBoard) {
              let playedBox = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
              playedBox.innerHTML = move.type;
          }
      };
      
      const checkDraw = () => {
          if (gameBoard.length == 9 && checkWinner() == false) {
              let msg = document.querySelector("#message");
              msg.innerHTML = "DRAW!";
              document.querySelector('#resetSec').classList.remove('displayNone');
              document.querySelector('#footer').classList.remove('displayNone');
              document.querySelector('#overlay').classList.add('overlay');
          }
      }
      
      
      
    </script>
  </body>
</html>